trigger:
- main

pool:
  name: Default
  vmImage: 'ubuntu-latest'

variables:
  - group: 'PhotoFlow'
  - name: azureSubscription
    value: 'AZ_PhotoFlow_connection'
  - name: subscriptionId
    value: 'ebe2acfb-f4a5-4f6b-8f30-252c571813f9'

  - name: resourceGroupName
    value: 'AzurePhotoFlow-RG'
  - name: location
    value: 'eastus'

  - name: containerRegistry
    value: 'ghcr.io/loicniragire/photoflow'


  - name: storageAccountName
    value: 'photoflowtfstatedev'
  - name: containerName
    value: 'tfstate'
  - name: logging
    value: 'logs'
  - name: cognitiveAccountName
    value: 'azurephotoflowvision'
  - name: tfStateFile
    value: 'azurephotoflow.tfstate'
  - name: stableTag
    value: "$(Build.BuildId)"
  - name: backendWebAppName
    value: "photoflowbackendwebapp"
  - name: frontendWebAppName
    value: "loicportraits"
  - name: backend_function_app_name
    value: "photoflowfunction"

resources:
  repositories:
    - repository: github_repo
      type: github
      name: Loicniragire/AzurePhotoFlow
      endpoint: 'github.com_Loicniragire'

stages:
# ---------------------------------------------------------------------------
# Build Stage
# ---------------------------------------------------------------------------
- stage: Build
  displayName: Build Stage
  jobs:
  - job: BuildDockerImages
    displayName: Build Docker Images (Backend & Frontend)
    steps:
      - checkout: github_repo

      # Verify CLIP model exists or download it
      - script: |
          if [ ! -f "models/model.onnx" ]; then
            echo "CLIP model not found. Downloading from Hugging Face..."
            mkdir -p models
            
            # Download CLIP ONNX model directly from Hugging Face
            curl -L -o models/model.onnx \
              "https://huggingface.co/openai/clip-vit-base-patch32/resolve/main/onnx/model.onnx" \
              || echo "Warning: Could not download CLIP model from Hugging Face"
              
            if [ -f "models/model.onnx" ]; then
              echo "CLIP model downloaded successfully"
              ls -la models/model.onnx
            else
              echo "ERROR: CLIP model is required but could not be downloaded"
              exit 1
            fi
          else
            echo "CLIP model already exists"
            ls -la models/model.onnx
          fi
        displayName: 'Ensure CLIP Model Exists'

      - script: |
          export DOCKER_CONFIG=$HOME/.docker
          docker context use desktop-linux
        displayName: 'Set Docker Context'

      # Create .env file
      - script: |
          echo "AZURE_BLOB_STORAGE=$(AZURE_BLOB_STORAGE)" > .env
          echo "CERTIFICATE_PASSWORD=$(CERTIFICATE_PASSWORD)" >> .env
          echo "CERTIFICATE_PATH=$(CERTIFICATE_PATH)" >> .env
          echo "MODE=$(MODE)" >> .env
          echo "CONTAINER_REGISTRY=$(containerRegistry)" >> .env
          echo "VITE_API_BASE_URL=$(VITE_API_BASE_URL)" >> .env
          echo "VITE_GOOGLE_CLIENT_ID=$(VITE_GOOGLE_CLIENT_ID)" >> .env
          echo "JWT_SECRET_KEY=$(JWT_SECRET_KEY)" >> .env
          echo "stableTag=$(Build.BuildId)" >> .env
          echo "ALLOWED_ORIGINS=$(ALLOWED_ORIGINS)" >> .env
          echo "QDRANT_URL=$(QDRANT_URL)" >> .env
          echo "QDRANT_COLLECTION=$(QDRANT_COLLECTION)" >> .env
          echo "CLIP_MODEL_PATH=$(CLIP_MODEL_PATH)" >> .env
          echo "METADATA_QUEUE=$(METADATA_QUEUE)" >> .env
        displayName: 'Create .env file'

      - publish: $(Build.SourcesDirectory)/.env
        artifact: env-artifact
        displayName: 'Publish .env File Artifact'

      # Build and Tag Docker Images for backend and frontend only
      - script: |
          set -e
          # Build only backend and frontend services (exclude function service)
          docker compose --env-file .env -f docker-compose.yml build backend frontend
          docker tag $(containerRegistry)/azurephotoflow-backend:$(Build.BuildId) $(containerRegistry)/azurephotoflow-backend:latest
          docker tag $(containerRegistry)/azurephotoflow-frontend:$(Build.BuildId) $(containerRegistry)/azurephotoflow-frontend:latest
        displayName: 'Build and Tag Backend & Frontend Images'

      # Login to ACR and Push Images for backend and frontend
      - script: |
            echo "$(GHCR_TOKEN)" | docker login ghcr.io \
              --username "$(GHCR_USERNAME)" \
              --password-stdin
        displayName: 'Login to GitHub Container Registry'

      - script: |
          echo "Pushing backend and frontend images to ACR..."

          docker push $(containerRegistry)/azurephotoflow-backend:$(Build.BuildId)
          docker push $(containerRegistry)/azurephotoflow-backend:latest

          docker push $(containerRegistry)/azurephotoflow-frontend:$(Build.BuildId)
          docker push $(containerRegistry)/azurephotoflow-frontend:latest

        displayName: 'Push Docker Images to ACR'

      - publish: $(Build.SourcesDirectory)/docker-compose.yml
        artifact: compose-artifact
        displayName: 'Publish docker-compose.yml Artifact'

  - job: BuildFunctionZip
    displayName: "Build Azure Function Zip Package"
    steps:
      - checkout: github_repo

      # Publish the Azure Function App
      - task: DotNetCoreCLI@2
        displayName: 'Publish Function App'
        inputs:
          command: publish
          publishWebProjects: false
          projects: 'backend/AzurePhotoFlow.Functions/AzurePhotoFlow.Functions.csproj'
          arguments: '--configuration Release --output $(Build.ArtifactStagingDirectory)/function_publish'
          zipAfterPublish: false

      # Archive the published output into a zip package
      - task: ArchiveFiles@2
        displayName: 'Archive Function App into Zip'
        inputs:
          rootFolderOrFile: '$(Build.ArtifactStagingDirectory)/function_publish'
          includeRootFolder: false
          archiveType: 'zip'
          archiveFile: '$(Build.ArtifactStagingDirectory)/functionapp.zip'
          replaceExistingArchive: true

      # Publish the zip package as an artifact
      - publish: '$(Build.ArtifactStagingDirectory)/functionapp.zip'
        artifact: functionapp-zip
        displayName: 'Publish Function Zip Artifact'

# ---------------------------------------------------------------------------
# Test Stage
# ---------------------------------------------------------------------------
- stage: Test
  displayName: Test Stage
  dependsOn: Build
  jobs:
  - job: RunTests
    displayName: Run Unit and Integration Tests
    steps:
      - checkout: self
      - script: |
          cd $(Build.SourcesDirectory)/tests/backend/AzurePhotoFlow.Api.Tests
          dotnet restore
          dotnet test
        displayName: 'Run Backend Tests'
      - script: |
          cd $(Build.SourcesDirectory)/tests/frontend
          npm install
          npm test
        displayName: 'Run Frontend Tests'

# ---------------------------------------------------------------------------
# Deploy Stage
# ---------------------------------------------------------------------------
- stage: Deploy
  displayName: Deploy to Kubernetes
  dependsOn: Test
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: DeployToKubernetes
    displayName: Deploy to Kubernetes Cluster
    environment: 'production'  # Create this environment in Azure DevOps
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: github_repo

          # Download build artifacts
          - download: current
            artifact: env-artifact
            displayName: 'Download Environment File'

          # Install kubectl
          - task: KubectlInstaller@0
            displayName: 'Install kubectl'
            inputs:
              kubectlVersion: 'latest'

          # Configure kubectl with your cluster
          # Replace this with your cluster connection method
          - task: Kubernetes@1
            displayName: 'Configure kubectl'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: 'your-k8s-connection'  # Create this service connection
              command: 'login'

          # Create Docker registry secret
          - script: |
              kubectl create secret docker-registry registry-secret \
                --docker-server=ghcr.io \
                --docker-username="$(GHCR_USERNAME)" \
                --docker-password="$(GHCR_TOKEN)" \
                --namespace=azurephotoflow \
                --dry-run=client -o yaml | kubectl apply -f -
            displayName: 'Create Registry Secret'

          # Update secrets with pipeline variables
          - script: |
              # Update secrets.yaml with actual values
              cd k8s
              
              # Encode secrets to base64
              VITE_GOOGLE_CLIENT_ID_B64=$(echo -n "$(VITE_GOOGLE_CLIENT_ID)" | base64 -w 0)
              JWT_SECRET_KEY_B64=$(echo -n "$(JWT_SECRET_KEY)" | base64 -w 0)
              
              # Update secrets file
              sed -i "s/REPLACE_WITH_BASE64_ENCODED_VALUE/$VITE_GOOGLE_CLIENT_ID_B64/g" secrets.yaml
              sed -i "s/REPLACE_WITH_BASE64_ENCODED_VALUE/$JWT_SECRET_KEY_B64/g" secrets.yaml
              
              # Update configmap with production values
              sed -i "s|VITE_API_BASE_URL:.*|VITE_API_BASE_URL: \"$(VITE_API_BASE_URL)\"|g" configmap.yaml
              sed -i "s|ALLOWED_ORIGINS:.*|ALLOWED_ORIGINS: \"$(ALLOWED_ORIGINS)\"|g" configmap.yaml
            displayName: 'Update Kubernetes Manifests'

          # Deploy to Kubernetes using the deployment script
          - script: |
              chmod +x scripts/deploy-k8s.sh
              ./scripts/deploy-k8s.sh production $(Build.BuildId)
            displayName: 'Deploy to Kubernetes'

          # Verify deployment
          - script: |
              echo "Verifying deployment..."
              kubectl get pods -n azurephotoflow
              kubectl get services -n azurephotoflow
              kubectl get ingress -n azurephotoflow
              
              # Wait for pods to be ready
              kubectl wait --for=condition=ready pod -l app=backend -n azurephotoflow --timeout=300s
              kubectl wait --for=condition=ready pod -l app=frontend -n azurephotoflow --timeout=300s
            displayName: 'Verify Deployment'

