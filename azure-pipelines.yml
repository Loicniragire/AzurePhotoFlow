trigger:
- main

pool:
  name: Default
  vmImage: 'ubuntu-latest'

variables:
  - group: 'PhotoFlow'

  - name: azureSubscription
    value: 'AZ_PhotoFlow_connection'
  - name: subscriptionId
    value: 'ebe2acfb-f4a5-4f6b-8f30-252c571813f9'
  - name: containerRegistryConnection
    value: 'AzurePhotoFlowACR_connection'
  - name: resourceGroupName
    value: 'AzurePhotoFlow-RG'
  - name: location
    value: 'eastus'
  - name: containerRegistry
    value: 'azurephotoflowacr.azurecr.io'
  - name: storageAccountName
    value: 'photoflowtfstatedev'
  - name: containerName
    value: 'tfstate'
  - name: docker-compose-container
    value: 'docker-compose'
  - name: cognitiveAccountName
    value: 'azurephotoflowvision'
  - name: tfStateFile
    value: 'azurephotoflow.tfstate'
  - name: stableTag
    value: "$(Build.BuildId)"

resources:
  repositories:
    - repository: github_repo
      type: github
      name: Loicniragire/AzurePhotoFlow
      endpoint: 'github.com_Loicniragire' 

stages:
# Build Stage
- stage: Build
  displayName: Build Stage
  jobs:
  - job: BuildDockerImages
    displayName: Build Docker Images
    steps:
      # Checkout source code
      - checkout: github_repo

      # Set Docker Context
      - script: |
          export DOCKER_CONFIG=$HOME/.docker
          docker context use desktop-linux
        displayName: 'Set Docker Context'

      - script: |
          echo "AZURE_BLOB_STORAGE=$(AZURE_BLOB_STORAGE)" > .env
          echo "CERTIFICATE_PASSWORD=$(CERTIFICATE_PASSWORD)" >> .env
          echo "CERTIFICATE_PATH=$(CERTIFICATE_PATH)" >> .env
          echo "MODE=$(MODE)" >> .env
          echo "VITE_API_BASE_URL=$(VITE_API_BASE_URL)"  >> .env
          echo "stableTag=$(Build.BuildId)" >> .env
        displayName: Create .env file for Docker Compose

        # Publish .env file as an artifact
      - publish: $(Build.SourcesDirectory)/.env
        artifact: env-artifact
        displayName: Publish .env file artifact

      - script: |
          echo "Printing .env file content for debugging:"
          cat .env
        displayName: Print .env file content for debugging

      - script: |
          docker compose --env-file .env -f docker-compose.yml build
          docker tag $(containerRegistry)/azurephotoflow-backend:$(Build.BuildId) $(containerRegistry)/azurephotoflow-backend:latest
          docker tag $(containerRegistry)/azurephotoflow-frontend:$(Build.BuildId) $(containerRegistry)/azurephotoflow-frontend:latest
          docker tag $(containerRegistry)/azurephotoflow-backend:$(Build.BuildId) $(containerRegistry)/azurephotoflow-backend:$(Build.BuildId)
          docker tag $(containerRegistry)/azurephotoflow-frontend:$(Build.BuildId) $(containerRegistry)/azurephotoflow-frontend:$(Build.BuildId)
        displayName: Build and Tag Images

       # Publish docker compose
      - publish: $(Build.SourcesDirectory)/docker-compose.yml
        artifact: compose-artifact
        displayName: Publish docker-compose.yml Artifact

# Test Stage
- stage: Test
  displayName: Test Stage
  dependsOn: Build
  jobs:
  - job: RunTests
    displayName: Run Unit and Integration Tests
    steps:
      - checkout: self
      # Run backend tests
      - script: |
          cd $(Build.SourcesDirectory)/tests/backend/AzurePhotoFlow.Api.Tests
          dotnet restore
          dotnet test
        displayName: Run Backend Tests

      # Run frontend tests
      - script: |
          cd $(Build.SourcesDirectory)/tests/frontend
          npm install
          npm test
        displayName: Run Frontend Tests

# Deploy Infrastructure Stage
- stage: DeployInfrastructure
  displayName: Deploy Infrastructure
  dependsOn: Test
  jobs:
  - job: DeployTerraform
    displayName: Deploy Infrastructure with Terraform
    variables:
    - group: 'PhotoFlow'
    steps:
      - script: |
          cd $(Build.SourcesDirectory)/Infrastructure
          terraform init \
            -backend-config="storage_account_name=$(storageAccountName)" \
            -backend-config="container_name=$(containerName)" \
            -backend-config="key=$(tfStateFile)" \
            -backend-config="resource_group_name=$(resourceGroupName)" \
            -backend-config="subscription_id=$(ARM_SUBSCRIPTION_ID)"
          terraform plan \
            -var="ssl_certificate_password=$(CERTIFICATE_PASSWORD)" \
            -var="app_service_fqdn=$(appServiceFqdn)" \
            -out=tfplan
          terraform apply \
            -auto-approve \
            -parallelism=5 \
            -lock-timeout=60s tfplan || exit 1
        displayName: Authenticate and Apply Terraform with Optimizations

# Deploy Applications Stage
- stage: DeployApplications
  displayName: Deploy Applications
  dependsOn: DeployInfrastructure
  variables:
    System.Debug: true
    docker_host: 'unix:///Users/loicniragire/.docker/run/docker.sock'
  jobs:
  - job: PushDockerImages
    displayName: Push Docker Images to ACR
    variables:
      - group: 'PhotoFlow'
    steps:
      # Login to Azure Container Registry
      - task: Docker@2
        displayName: Login to ACR
        inputs:
          command: login
          containerRegistry: $(containerRegistryConnection)
      - script: |
          echo "Using Container Registry: $(containerRegistryConnection)"
        displayName: 'Verify Container Registry Variable'

      - script: |
          export DOCKER_CONFIG=$HOME/.docker
          docker context use desktop-linux
        displayName: 'Set Docker Context with Config'

      - script: |
          docker context ls
        displayName: 'Verify Docker Contexts'

      - script: |
          export DOCKER_HOST=$(docker_host)
          docker ps
        displayName: 'Test Docker Connection'


      # Download the .env file artifact from previous stage
      - download: current
        artifact: env-artifact

      # Push Docker Images
      - script: |
          ls -l $(Pipeline.Workspace)/env-artifact/.env
          cat $(Pipeline.Workspace)/env-artifact/.env  
          docker compose --env-file $(Pipeline.Workspace)/env-artifact/.env -f docker-compose.yml push
        displayName: Push docker images to ACR

  - job: DeployMultiContainers
    displayName: Deploy Multi-Container App Service
    dependsOn: PushDockerImages
    steps:
      # (1) Login to ACR
      - task: Docker@2
        displayName: Login to ACR
        inputs:
          command: login
          containerRegistry: $(containerRegistryConnection)
      
      # (2) Download artifacts
      - download: current
        artifact: compose-artifact
      - download: current
        artifact: env-artifact

      # (3) Docker Compose Pull/Up
      - script: |
          docker compose --env-file $(Pipeline.Workspace)/env-artifact/.env -f docker-compose.yml pull
        displayName: Pull Docker Images

      # (4) Deploy Multi-Container Configuration to Azure
      - script: |
          az storage container create \
              --account-name $(storageAccountName) \
              --name $(docker-compose-container) \
              --auth-mode login
          az storage blob upload \
              --account-name $(storageAccountName) \
              --container-name $(docker-compose-container) \
              --file $(Pipeline.Workspace)/compose-artifact/docker-compose.yml \
              --name docker-compose.yml \
              --auth-mode key \
              --overwrite
        displayName: Upload docker-compose.yml to Azure Blob Storage

      - script: |
          az resource update \
            --resource-group $(resourceGroupName) \
            --name AzurePhotoFlowWebApp \
            --resource-type "Microsoft.Web/sites" \
            --set properties.siteConfig.linuxFxVersion="COMPOSE|https://$(storageAccountName).blob.core.windows.net/$(docker-compose-container)/docker-compose.yml"
        displayName: Deploy Multi-Container Configuration

      # (5) Configure App Settings
      - script: |
          az webapp config appsettings set \
            --name AzurePhotoFlowWebApp \
            --resource-group $(resourceGroupName) \
            --settings \
              "AZURE_BLOB_STORAGE=$(AZURE_BLOB_STORAGE)" \
              "VITE_API_BASE_URL=$(VITE_API_BASE_URL)" \
              "CERTIFICATE_PASSWORD=$(CERTIFICATE_PASSWORD)" \
              "CERTIFICATE_PATH=$(CERTIFICATE_PATH)" \
              "NODE_ENV=production" \
              "WEBSITES_ENABLE_APP_SERVICE_STORAGE=true"
        displayName: Configure App Service Environment Variables

      - script: |
          az webapp log config \
            --name AzurePhotoFlowWebApp \
            --resource-group $(resourceGroupName) \
            --docker-container-logging filesystem
            --application-logging filesystem \
            --level Information \
            --detailed-error-messages true \
            --failed-request-tracing true \
            --web-server-logging filesystem

        displayName: Enabling filesystem logs

      - script: |
          az resource show \
            --name AzurePhotoFlowWebApp \
            --resource-group AzurePhotoFlow-RG
            # --resource-type "Microsoft.Web/sites" \
            # --query "properties.siteConfig.linuxFxVersion"
        displayName: Check deployment status


      # (6) Wait For Health Endpoint
      - script: |
          echo "Waiting for container to become healthy..."
          MAX_ATTEMPTS=6
          SLEEP_BETWEEN=10
          ATTEMPT=1
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]
          do
            echo "Attempt $ATTEMPT: Checking /health endpoint..."
            curl -s -f https://AzurePhotoFlowWebApp.azurewebsites.net/health && break
            echo "Health check unavailable. Waiting $SLEEP_BETWEEN seconds before retry..."
            ATTEMPT=$((ATTEMPT+1))
            sleep $SLEEP_BETWEEN
          done
          if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
            echo "Health check failed after $MAX_ATTEMPTS attempts!"
            exit 1
          fi
          echo "Container is healthy!"
        displayName: Wait for /health endpoint

      # (7) (Optional) Final Single Check
      - script: |
          curl -I https://AzurePhotoFlowWebApp.azurewebsites.net/health
        displayName: Perform Health Check

- stage: Validate
  displayName: Validation Stage
  dependsOn: DeployApplications
  jobs:
  - job: SmokeTest
    steps:
    - script: |
        curl -sSf "https://$(appServiceFqdn)/" | grep "React App"
        curl -sSf "https://$(appServiceFqdn)/api/health" | grep "Healthy"
      displayName: Run Smoke Tests
