trigger:
- main

pool:
  name: Default
  vmImage: 'ubuntu-latest'

variables:
  - group: 'PhotoFlow'
  - name: containerRegistry
    value: 'ghcr.io/loicniragire/photoflow'
  - name: stableTag
    value: "$(Build.BuildId)"
  - name: deploymentConfigured
    value: ${{ variables.REMOTE_DEPLOYMENT_CONFIGURED }}

resources:
  repositories:
    - repository: github_repo
      type: github
      name: Loicniragire/AzurePhotoFlow
      endpoint: 'github.com_Loicniragire'

stages:
# ---------------------------------------------------------------------------
# Build Stage
# ---------------------------------------------------------------------------
- stage: Build
  displayName: Build Stage
  jobs:
  - job: BuildAndPush
    displayName: Build and Push Docker Images
    steps:
      - checkout: github_repo

      # Verify CLIP model exists or download it
      - script: |
          if [ ! -f "models/model.onnx" ]; then
            echo "CLIP model not found. Downloading from Hugging Face..."
            mkdir -p models
            curl -L -o models/model.onnx \
              "https://huggingface.co/openai/clip-vit-base-patch32/resolve/main/onnx/model.onnx" \
              || echo "Warning: Could not download CLIP model from Hugging Face"
              
            if [ -f "models/model.onnx" ]; then
              echo "CLIP model downloaded successfully"
              ls -la models/model.onnx
            else
              echo "ERROR: CLIP model is required but could not be downloaded"
              exit 1
            fi
          else
            echo "CLIP model already exists"
            ls -la models/model.onnx
          fi
        displayName: 'Ensure CLIP Model Exists'

      # Create .env file
      - script: |
          echo "MODE=$(MODE)" > .env
          echo "CONTAINER_REGISTRY=$(containerRegistry)" >> .env
          echo "VITE_API_BASE_URL=$(VITE_API_BASE_URL)" >> .env
          echo "VITE_GOOGLE_CLIENT_ID=$(VITE_GOOGLE_CLIENT_ID)" >> .env
          echo "JWT_SECRET_KEY=$(JWT_SECRET_KEY)" >> .env
          echo "stableTag=$(Build.BuildId)" >> .env
          echo "ALLOWED_ORIGINS=$(ALLOWED_ORIGINS)" >> .env
          echo "QDRANT_URL=$(QDRANT_URL)" >> .env
          echo "QDRANT_COLLECTION=$(QDRANT_COLLECTION)" >> .env
          echo "CLIP_MODEL_PATH=$(CLIP_MODEL_PATH)" >> .env
        displayName: 'Create .env file'

      # Build Docker Images
      - script: |
          set -e
          docker compose --env-file .env -f docker-compose.yml build backend frontend
          docker tag $(containerRegistry)/azurephotoflow-backend:$(Build.BuildId) $(containerRegistry)/azurephotoflow-backend:latest
          docker tag $(containerRegistry)/azurephotoflow-frontend:$(Build.BuildId) $(containerRegistry)/azurephotoflow-frontend:latest
        displayName: 'Build Docker Images'

      # Login and Push to Container Registry
      - script: |
          echo "$(GHCR_TOKEN)" | docker login ghcr.io \
            --username "$(GHCR_USERNAME)" \
            --password-stdin
        displayName: 'Login to GitHub Container Registry'

      - script: |
          echo "Pushing images to container registry..."
          docker push $(containerRegistry)/azurephotoflow-backend:$(Build.BuildId)
          docker push $(containerRegistry)/azurephotoflow-backend:latest
          docker push $(containerRegistry)/azurephotoflow-frontend:$(Build.BuildId)
          docker push $(containerRegistry)/azurephotoflow-frontend:latest
        displayName: 'Push Docker Images'

      # Publish deployment artifacts
      - publish: $(Build.SourcesDirectory)/k8s
        artifact: k8s-manifests
        displayName: 'Publish Kubernetes Manifests'

      - publish: $(Build.SourcesDirectory)/scripts
        artifact: deployment-scripts
        displayName: 'Publish Deployment Scripts'

      - publish: $(Build.SourcesDirectory)/.env
        artifact: env-artifact
        displayName: 'Publish Environment File'

# ---------------------------------------------------------------------------
# Test Stage
# ---------------------------------------------------------------------------
- stage: Test
  displayName: Test Stage
  dependsOn: Build
  jobs:
  - job: RunTests
    displayName: Run Unit and Integration Tests
    steps:
      - checkout: self
      
      - script: |
          cd $(Build.SourcesDirectory)/tests/backend/AzurePhotoFlow.Api.Tests
          dotnet restore
          dotnet test --logger "trx;LogFileName=backend-tests.trx"
        displayName: 'Run Backend Tests'
      
      - task: PublishTestResults@2
        displayName: 'Publish Backend Test Results'
        inputs:
          testResultsFormat: 'VSTest'
          testResultsFiles: '**/backend-tests.trx'
          failTaskOnFailedTests: true

# ---------------------------------------------------------------------------
# Deployment Approval Stage
# ---------------------------------------------------------------------------
- stage: DeploymentApproval
  displayName: 🚀 Deploy to Remote Cluster?
  dependsOn: Test
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - job: CheckDeploymentConfig
    displayName: Check Deployment Configuration
    steps:
      - script: |
          echo "Checking if remote deployment is configured..."
          
          # Check if required deployment variables are set
          if [ -z "$(REMOTE_SSH_HOST)" ] || [ -z "$(REMOTE_SSH_USER)" ]; then
            echo "##vso[task.logissue type=warning]Remote deployment not configured"
            echo "##vso[task.logissue type=warning]Please set REMOTE_SSH_HOST and REMOTE_SSH_USER variables"
            echo "##vso[task.setvariable variable=deploymentConfigured]false"
          else
            echo "Remote deployment is configured"
            echo "Target: $(REMOTE_SSH_USER)@$(REMOTE_SSH_HOST)"
            echo "##vso[task.setvariable variable=deploymentConfigured]true"
          fi
        displayName: 'Check Deployment Configuration'

  - deployment: ApprovalGate
    displayName: 🎯 Deployment Approval
    environment: 'production-approval'  # Requires manual approval in Azure DevOps
    condition: eq(variables.deploymentConfigured, 'true')
    strategy:
      runOnce:
        deploy:
          steps:
          - script: |
              echo "🎉 Deployment approved!"
              echo "Proceeding with deployment to remote cluster..."
              echo "Target: $(REMOTE_SSH_USER)@$(REMOTE_SSH_HOST)"
              echo "Image Tag: $(Build.BuildId)"
            displayName: 'Deployment Approved'

# ---------------------------------------------------------------------------
# Remote Deployment Stage
# ---------------------------------------------------------------------------
- stage: RemoteDeploy
  displayName: 🚀 Deploy to Remote Cluster
  dependsOn: DeploymentApproval
  condition: and(succeeded(), eq(variables.deploymentConfigured, 'true'))
  jobs:
  - deployment: DeployToRemoteCluster
    displayName: Deploy to Remote MicroK8s
    environment: 'production-deployment'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: github_repo
          
          # Download artifacts
          - download: current
            artifact: k8s-manifests
            displayName: 'Download Kubernetes Manifests'
          
          - download: current
            artifact: deployment-scripts
            displayName: 'Download Deployment Scripts'

          - download: current
            artifact: env-artifact
            displayName: 'Download Environment File'

          # Setup SSH for deployment
          - script: |
              echo "Setting up SSH for remote deployment..."
              
              # Create SSH directory
              mkdir -p ~/.ssh
              chmod 700 ~/.ssh
              
              # Add SSH key from pipeline variable
              echo "$(REMOTE_SSH_PRIVATE_KEY)" > ~/.ssh/azure_pipeline_key
              chmod 600 ~/.ssh/azure_pipeline_key
              
              # Test SSH connection
              ssh -i ~/.ssh/azure_pipeline_key \
                  -o StrictHostKeyChecking=no \
                  -o UserKnownHostsFile=/dev/null \
                  -o LogLevel=ERROR \
                  -o ConnectTimeout=10 \
                  $(REMOTE_SSH_USER)@$(REMOTE_SSH_HOST) \
                  'echo "SSH connection successful"'
              
              # Set environment variables for deployment scripts
              echo "export SSH_HOST=$(REMOTE_SSH_HOST)" > ~/.ssh_env
              echo "export SSH_USER=$(REMOTE_SSH_USER)" >> ~/.ssh_env
              echo "export SSH_KEY=~/.ssh/azure_pipeline_key" >> ~/.ssh_env
              echo "export SSH_PORT=${REMOTE_SSH_PORT:-22}" >> ~/.ssh_env
              
              source ~/.ssh_env
              echo "SSH setup completed"
            displayName: 'Setup SSH Connection'

          # Prepare deployment files
          - script: |
              echo "Preparing deployment files..."
              
              # Copy downloaded artifacts to working directory
              cp -r $(Pipeline.Workspace)/k8s-manifests/* k8s/
              cp -r $(Pipeline.Workspace)/deployment-scripts/* scripts/
              
              # Make scripts executable
              chmod +x scripts/*.sh
              
              # Update Kubernetes manifests with pipeline values
              cd k8s
              
              # Update image tags
              sed -i "s/:latest/:$(Build.BuildId)/g" app/backend-deployment.yaml
              sed -i "s/:latest/:$(Build.BuildId)/g" app/frontend-deployment.yaml
              
              # Update configmap with production values  
              sed -i "s|your-domain.com|$(PRODUCTION_DOMAIN)|g" configmap.yaml
              sed -i "s|your-domain.com|$(PRODUCTION_DOMAIN)|g" ingress-microk8s.yaml
              sed -i "s|VITE_API_BASE_URL:.*|VITE_API_BASE_URL: \"https://$(PRODUCTION_DOMAIN)/api\"|g" configmap.yaml
              sed -i "s|ALLOWED_ORIGINS:.*|ALLOWED_ORIGINS: \"https://$(PRODUCTION_DOMAIN)\"|g" configmap.yaml
              
              echo "Deployment files prepared"
            displayName: 'Prepare Deployment Files'

          # Deploy to remote cluster
          - script: |
              echo "🚀 Starting deployment to remote MicroK8s cluster..."
              
              # Source SSH environment
              source ~/.ssh_env
              
              # Create a comprehensive deployment script
              cat > deploy_pipeline.sh << 'EOF'
              #!/bin/bash
              set -e
              
              # Load SSH environment
              source ~/.ssh_env
              
              echo "📋 Deployment Information:"
              echo "  Target: $SSH_USER@$SSH_HOST"
              echo "  Image Tag: $(Build.BuildId)"
              echo "  Domain: $(PRODUCTION_DOMAIN)"
              echo ""
              
              # Step 1: Test cluster connectivity
              echo "🔍 Testing cluster connectivity..."
              ./scripts/ssh-helper.sh test
              
              # Step 2: Create/update secrets
              echo "🔐 Setting up application secrets..."
              ssh $SSH_USER@$SSH_HOST 'microk8s kubectl create namespace azurephotoflow --dry-run=client -o yaml | microk8s kubectl apply -f -'
              
              # Create secrets using pipeline variables
              ssh $SSH_USER@$SSH_HOST "microk8s kubectl create secret generic azurephotoflow-secrets \
                --from-literal=VITE_GOOGLE_CLIENT_ID='$(VITE_GOOGLE_CLIENT_ID)' \
                --from-literal=JWT_SECRET_KEY='$(JWT_SECRET_KEY)' \
                --from-literal=MINIO_ACCESS_KEY='$(MINIO_ACCESS_KEY)' \
                --from-literal=MINIO_SECRET_KEY='$(MINIO_SECRET_KEY)' \
                --namespace=azurephotoflow \
                --dry-run=client -o yaml | microk8s kubectl apply -f -"
              
              # Create registry secret
              ssh $SSH_USER@$SSH_HOST "microk8s kubectl create secret docker-registry registry-secret \
                --docker-server=ghcr.io \
                --docker-username='$(GHCR_USERNAME)' \
                --docker-password='$(GHCR_TOKEN)' \
                --namespace=azurephotoflow \
                --dry-run=client -o yaml | microk8s kubectl apply -f -"
              
              echo "✅ Secrets configured"
              
              # Step 3: Deploy application
              echo "🚀 Deploying application components..."
              
              # Copy manifests to remote server
              scp -r k8s/ $SSH_USER@$SSH_HOST:/tmp/k8s-deploy-$(Build.BuildId)/
              
              # Deploy using remote kubectl
              ssh $SSH_USER@$SSH_HOST "cd /tmp/k8s-deploy-$(Build.BuildId) && \
                microk8s kubectl apply -f namespace.yaml && \
                microk8s kubectl apply -f configmap.yaml && \
                microk8s kubectl apply -f storage/ && \
                microk8s kubectl apply -f app/ && \
                microk8s kubectl apply -f ingress-microk8s.yaml"
              
              echo "✅ Application deployed"
              
              # Step 4: Wait for deployment to be ready
              echo "⏳ Waiting for deployments to be ready..."
              ssh $SSH_USER@$SSH_HOST 'microk8s kubectl wait --for=condition=available --timeout=300s deployment/minio-deployment -n azurephotoflow'
              ssh $SSH_USER@$SSH_HOST 'microk8s kubectl wait --for=condition=available --timeout=300s deployment/qdrant-deployment -n azurephotoflow'
              ssh $SSH_USER@$SSH_HOST 'microk8s kubectl wait --for=condition=available --timeout=300s deployment/backend-deployment -n azurephotoflow'
              ssh $SSH_USER@$SSH_HOST 'microk8s kubectl wait --for=condition=available --timeout=300s deployment/frontend-deployment -n azurephotoflow'
              
              echo "✅ All deployments ready"
              
              # Step 5: Cleanup
              ssh $SSH_USER@$SSH_HOST "rm -rf /tmp/k8s-deploy-$(Build.BuildId)"
              
              echo "🎉 Deployment completed successfully!"
              EOF
              
              chmod +x deploy_pipeline.sh
              ./deploy_pipeline.sh
            displayName: 'Deploy to Remote Cluster'

          # Post-deployment verification
          - script: |
              echo "🔍 Post-deployment verification..."
              
              source ~/.ssh_env
              
              # Show deployment status
              echo "📊 Deployment Status:"
              ssh $SSH_USER@$SSH_HOST 'microk8s kubectl get pods -n azurephotoflow'
              echo ""
              ssh $SSH_USER@$SSH_HOST 'microk8s kubectl get services -n azurephotoflow'
              echo ""
              ssh $SSH_USER@$SSH_HOST 'microk8s kubectl get ingress -n azurephotoflow'
              
              # Get access information
              echo ""
              echo "🌍 Access Information:"
              echo "  Frontend: https://$(PRODUCTION_DOMAIN)"
              echo "  API: https://$(PRODUCTION_DOMAIN)/api"
              echo "  Health Check: https://$(PRODUCTION_DOMAIN)/api/health"
              
              # Test health endpoint
              echo ""
              echo "🧪 Testing application health..."
              for i in {1..5}; do
                if ssh $SSH_USER@$SSH_HOST 'microk8s kubectl exec -n azurephotoflow deployment/backend-deployment -- curl -f http://localhost:8080/health' >/dev/null 2>&1; then
                  echo "✅ Backend health check passed"
                  break
                else
                  echo "⏳ Waiting for backend to be ready... (attempt $i/5)"
                  sleep 10
                fi
              done
              
              echo ""
              echo "🎯 Deployment Summary:"
              echo "  Build ID: $(Build.BuildId)"
              echo "  Target: $(REMOTE_SSH_USER)@$(REMOTE_SSH_HOST)"
              echo "  Domain: $(PRODUCTION_DOMAIN)"
              echo "  Status: ✅ SUCCESS"
            displayName: 'Verify Deployment'

# ---------------------------------------------------------------------------
# Notification Stage
# ---------------------------------------------------------------------------
- stage: Notification
  displayName: 📢 Send Notifications
  dependsOn: 
  - RemoteDeploy
  condition: always()
  jobs:
  - job: SendNotification
    displayName: Send Deployment Notification
    steps:
      - script: |
          if [ "$(Agent.JobStatus)" = "Succeeded" ]; then
            echo "🎉 Deployment successful!"
            echo "Application is now live at: https://$(PRODUCTION_DOMAIN)"
          else
            echo "❌ Deployment failed!"
            echo "Please check the pipeline logs for details."
          fi
          
          # Here you could add email, Slack, or Teams notifications
          # Example: Send to Teams webhook
          # curl -H "Content-Type: application/json" -d '{"text":"Deployment Status: $(Agent.JobStatus)"}' $(TEAMS_WEBHOOK_URL)
        displayName: 'Send Notification'
