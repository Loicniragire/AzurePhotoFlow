trigger:
- main

pool:
  name: Default
  vmImage: 'ubuntu-latest'

variables:
  - group: 'PhotoFlow'
  - name: azureSubscription
    value: 'AZ_PhotoFlow_connection'
  - name: subscriptionId
    value: 'ebe2acfb-f4a5-4f6b-8f30-252c571813f9'
  - name: containerRegistryConnection
    value: 'AzurePhotoFlowACR_connection'
  - name: resourceGroupName
    value: 'AzurePhotoFlow-RG'
  - name: location
    value: 'eastus'
  - name: containerRegistry
    value: 'azurephotoflowacr.azurecr.io'
  - name: storageAccountName
    value: 'photoflowtfstatedev'
  - name: containerName
    value: 'tfstate'
  - name: docker-compose-container
    value: 'docker-compose'
  - name: logging
    value: 'logs'
  - name: cognitiveAccountName
    value: 'azurephotoflowvision'
  - name: tfStateFile
    value: 'azurephotoflow.tfstate'
  - name: stableTag
    value: "$(Build.BuildId)"

resources:
  repositories:
    - repository: github_repo
      type: github
      name: Loicniragire/AzurePhotoFlow
      endpoint: 'github.com_Loicniragire'

stages:
# ---------------------------------------------------------------------------
# Build Stage
# ---------------------------------------------------------------------------
- stage: Build
  displayName: Build Stage
  jobs:
  - job: BuildDockerImages
    displayName: Build Docker Images
    steps:
      # Checkout source code
      - checkout: github_repo

      # Set Docker Context
      - script: |
          export DOCKER_CONFIG=$HOME/.docker
          docker context use desktop-linux
        displayName: 'Set Docker Context'

      # Create .env file for Docker Compose
      - script: |
          echo "AZURE_BLOB_STORAGE=$(AZURE_BLOB_STORAGE)" > .env
          echo "CERTIFICATE_PASSWORD=$(CERTIFICATE_PASSWORD)" >> .env
          echo "CERTIFICATE_PATH=$(CERTIFICATE_PATH)" >> .env
          echo "MODE=$(MODE)" >> .env
          echo "VITE_API_BASE_URL=$(VITE_API_BASE_URL)"  >> .env
          echo "stableTag=$(Build.BuildId)" >> .env
        displayName: Create .env file for Docker Compose

      # Publish the .env file as an artifact
      - publish: $(Build.SourcesDirectory)/.env
        artifact: env-artifact
        displayName: Publish .env File Artifact

      # Print the .env file content for debugging
      - script: |
          echo "Printing .env file content for debugging:"
          cat .env
        displayName: Print .env File Content

      # Build and Tag Docker Images
      - script: |
          set -e
          docker compose --env-file .env -f docker-compose.yml build
          docker tag $(containerRegistry)/azurephotoflow-backend:$(Build.BuildId) $(containerRegistry)/azurephotoflow-backend:latest
          docker tag $(containerRegistry)/azurephotoflow-frontend:$(Build.BuildId) $(containerRegistry)/azurephotoflow-frontend:latest
          docker tag $(containerRegistry)/azurephotoflow-backend:$(Build.BuildId) $(containerRegistry)/azurephotoflow-backend:$(Build.BuildId)
          docker tag $(containerRegistry)/azurephotoflow-frontend:$(Build.BuildId) $(containerRegistry)/azurephotoflow-frontend:$(Build.BuildId)
        displayName: Build and Tag Images

      # Publish the docker-compose.yml file as an artifact
      - publish: $(Build.SourcesDirectory)/docker-compose.yml
        artifact: compose-artifact
        displayName: Publish docker-compose.yml Artifact

# ---------------------------------------------------------------------------
# Test Stage
# ---------------------------------------------------------------------------
- stage: Test
  displayName: Test Stage
  dependsOn: Build
  jobs:
  - job: RunTests
    displayName: Run Unit and Integration Tests
    steps:
      - checkout: self
      # Run backend tests
      - script: |
          cd $(Build.SourcesDirectory)/tests/backend/AzurePhotoFlow.Api.Tests
          dotnet restore
          dotnet test
        displayName: Run Backend Tests
      # Run frontend tests
      - script: |
          cd $(Build.SourcesDirectory)/tests/frontend
          npm install
          npm test
        displayName: Run Frontend Tests

# ---------------------------------------------------------------------------
# Deploy Infrastructure Stage
# ---------------------------------------------------------------------------
- stage: DeployInfrastructure
  displayName: Deploy Infrastructure
  dependsOn: Test
  jobs:
  - job: DeployTerraform
    displayName: Deploy Infrastructure with Terraform
    variables:
      - group: 'PhotoFlow'
    steps:
      - script: |
          cd $(Build.SourcesDirectory)/Infrastructure
          terraform init \
            -backend-config="storage_account_name=$(storageAccountName)" \
            -backend-config="container_name=$(containerName)" \
            -backend-config="key=$(tfStateFile)" \
            -backend-config="resource_group_name=$(resourceGroupName)" \
            -backend-config="subscription_id=$(ARM_SUBSCRIPTION_ID)"
          terraform plan \
            -var="ssl_certificate_password=$(CERTIFICATE_PASSWORD)" \
            -var="app_service_fqdn=$(appServiceFqdn)" \
            -out=tfplan
          terraform apply \
            -auto-approve \
            -parallelism=5 \
            -lock-timeout=60s tfplan || exit 1
        displayName: Authenticate and Apply Terraform with Optimizations

# ---------------------------------------------------------------------------
# Deploy Applications Stage
# ---------------------------------------------------------------------------
- stage: DeployApplications
  displayName: Deploy Applications
  dependsOn: DeployInfrastructure
  variables:
    System.Debug: true
    docker_host: 'unix:///Users/loicniragire/.docker/run/docker.sock'
  jobs:
  # Push Docker Images to ACR
  - job: PushDockerImages
    displayName: Push Docker Images to ACR
    variables:
      - group: 'PhotoFlow'
    steps:
      - task: Docker@2
        displayName: Login to ACR
        inputs:
          command: login
          containerRegistry: $(containerRegistryConnection)
      - script: |
          echo "Using Container Registry: $(containerRegistryConnection)"
        displayName: 'Verify Container Registry Variable'
      - script: |
          export DOCKER_CONFIG=$HOME/.docker
          docker context use desktop-linux
        displayName: 'Set Docker Context with Config'
      - script: |
          docker context ls
        displayName: 'Verify Docker Contexts'
      - script: |
          export DOCKER_HOST=$(docker_host)
          docker ps
        displayName: 'Test Docker Connection'
      - download: current
        artifact: env-artifact
      - script: |
          ls -l $(Pipeline.Workspace)/env-artifact/.env
          cat $(Pipeline.Workspace)/env-artifact/.env  
          docker compose --env-file $(Pipeline.Workspace)/env-artifact/.env -f docker-compose.yml push
        displayName: Push Docker Images to ACR

  # Deploy Multi-Container App Service
  - job: DeployMultiContainers
    displayName: Deploy Multi-Container App Service
    dependsOn: PushDockerImages
    steps:
      - task: Docker@2
        displayName: Login to ACR
        inputs:
          command: login
          containerRegistry: $(containerRegistryConnection)
      - download: current
        artifact: compose-artifact
      - script: |
          echo "Substituting placeholders in docker-compose.yml..."
          # Display the original docker-compose file for debugging
          cat $(Pipeline.Workspace)/compose-artifact/docker-compose.yml
          # Substitute environment variables into a new self-contained file
          envsubst < $(Pipeline.Workspace)/compose-artifact/docker-compose.yml > $(Pipeline.Workspace)/compose-artifact/docker-compose.final.yml
          echo "Resulting self-contained docker-compose file:"
          cat $(Pipeline.Workspace)/compose-artifact/docker-compose.final.yml
        displayName: "Substitute Placeholders in docker-compose File"
      - script: |
          echo "Pulling Docker images using substituted docker-compose file..."
          docker compose -f $(Pipeline.Workspace)/compose-artifact/docker-compose.final.yml pull
        displayName: Pull Docker Images
      - script: |
          echo "Creating docker-compose container..."
          az storage container create \
              --account-name $(storageAccountName) \
              --name $(docker-compose-container) \
              --public-access blob \
              --auth-mode login
          echo "Updating storage account to allow public blob access..."
          az storage account update \
            --name $(storageAccountName) \
            --resource-group $(resourceGroupName) \
            --set allowBlobPublicAccess=true
          echo "Uploading self-contained docker-compose file to Azure Blob Storage..."
          az storage blob upload \
              --account-name $(storageAccountName) \
              --container-name $(docker-compose-container) \
              --file $(Pipeline.Workspace)/compose-artifact/docker-compose.final.yml \
              --name docker-compose.yml \
              --auth-mode key \
              --overwrite
        displayName: Upload docker-compose.yml to Azure Blob Storage
      - script: |
          echo "Deploying Multi-Container Configuration to Azure App Service..."
          az resource update \
            --resource-group $(resourceGroupName) \
            --name AzurePhotoFlowWebApp \
            --resource-type "Microsoft.Web/sites" \
            --set properties.siteConfig.clientCertMode="Optional" \
            --set properties.siteConfig.linuxFxVersion="COMPOSE|https://$(storageAccountName).blob.core.windows.net/$(docker-compose-container)/docker-compose.yml"
        displayName: Deploy Multi-Container Configuration
      - script: |
          echo "Configuring App Service environment variables..."
          az webapp config appsettings set \
            --name AzurePhotoFlowWebApp \
            --resource-group $(resourceGroupName) \
            --settings \
              "AZURE_BLOB_STORAGE=$(AZURE_BLOB_STORAGE)" \
              "VITE_API_BASE_URL=$(VITE_API_BASE_URL)" \
              "CERTIFICATE_PASSWORD=$(CERTIFICATE_PASSWORD)" \
              "CERTIFICATE_PATH=$(CERTIFICATE_PATH)" \
              "NODE_ENV=production" \
              "WEBSITES_ENABLE_APP_SERVICE_STORAGE=true"
        displayName: Configure App Service Environment Variables
      - script: |
          az webapp log config \
            --name AzurePhotoFlowWebApp \
            --resource-group $(resourceGroupName) \
            --docker-container-logging filesystem \
            --application-logging filesystem \
            --level verbose \
            --web-server-logging filesystem \
            --detailed-error-messages true \
            --failed-request-tracing true
        displayName: Enabling Filesystem Logs
      - script: |
          az resource show \
            --name AzurePhotoFlowWebApp \
            --resource-group $(resourceGroupName) \
            --resource-type "Microsoft.Web/sites" \
            --query "properties.siteConfig.linuxFxVersion"
        displayName: Check Deployment Status

  # Wait For Health Endpoint
  - job: WaitForHealthEndpoint
    displayName: Wait For Health Endpoint
    dependsOn: DeployMultiContainers
    steps:
      - script: |
          echo "Waiting for container to become healthy..."
          MAX_ATTEMPTS=6
          SLEEP_BETWEEN=10
          ATTEMPT=1
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]
          do
            echo "Attempt $ATTEMPT: Checking /health endpoint..."
            curl -s -f https://AzurePhotoFlowWebApp.azurewebsites.net/health && break
            echo "Health check unavailable. Waiting $SLEEP_BETWEEN seconds before retry..."
            ATTEMPT=$((ATTEMPT+1))
            sleep $SLEEP_BETWEEN
          done
          if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
            echo "Health check failed after $MAX_ATTEMPTS attempts!"
            exit 1
          fi
          echo "Container is healthy!"
        displayName: Wait for /health Endpoint

  # Perform Health Check
  - job: PerformHealthCheck
    displayName: Perform Health Check
    dependsOn: WaitForHealthEndpoint
    steps:
      - script: |
          curl -I https://AzurePhotoFlowWebApp.azurewebsites.net/health
        displayName: Check /health Endpoint

# ---------------------------------------------------------------------------
# Validate Stage
# ---------------------------------------------------------------------------
- stage: Validate
  displayName: Validation Stage
  dependsOn: DeployApplications
  jobs:
  - job: SmokeTest
    displayName: Smoke Test
    steps:
      - script: |
          curl -sSf "https://$(appServiceFqdn)/" | grep "React App"
          curl -sSf "https://$(appServiceFqdn)/api/health" | grep "Healthy"
        displayName: Run Smoke Tests

